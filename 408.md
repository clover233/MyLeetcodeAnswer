### 进程和线程的区别

- 进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。
- 线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。
- 一个进程可以有多个线程，多个线程也可以并发执行

###  进程的通信方式

主要分为：管道、系统**IPC**（包括消息队列、信号量、共享存储）、**SOCKET**

管道主要分为：普通管道**PIPE** 、流管道（**s_pipe**）、命名管道（**name_pipe**）

- 管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程
- 命名管道也是半双工的通信方式，它允许无亲缘关系的进程间进行通信
- 信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。
- 消息队列是消息的链表，存放在内核中并由消息队列标识符标识。
- 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
- 共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。

### 死锁产生的条件  

- 互斥：一个资源一次只能被一个进程使用
- 请求与保持：一个进程因请求资源而阻塞时，对已获得资源保持不放
- 不剥夺：进程获得的资源，在未完全使用完之前，不能强行剥夺
- 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系

### 死锁的处理基本策略 

 预防死锁、避免死锁（银行家算法）、检测死锁（资源分配图）、解除死锁 

### HTTP和HTTPS区别

http是超文本传输协议，信息是明文传输；https则是具有安全性的ssl加密传输协议。 

 不同的连接方式，用的端口也不一样，http是 80,https是 443。 

> HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：
>
> - TCP 三次同步握手
> - 客户端验证服务器数字证书
> - DH 算法协商对称加密算法的密钥、hash 算法的密钥
> - SSL 安全加密隧道协商完成
> - 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；
> - 用协商的hash算法进行数据完整性保护，保证数据不被篡改。

### TCP和UDP区别

TCP和UDP是OSI模型中的运输层中的协议。

两者的区别大致如下：

- TCP面向连接，UDP面向非连接（即发送数据前不需要建立链接）
- TCP提供可靠的通信传输，而UDP则不可靠传输。
- TCP面向字节流，UDP面向报文。
- TCP数据传输慢，UDP数据传输快。

### TCP三次握手/四次握手

* **TCP三次建立连接：**
  * **客户机**的TCP首先向**服务器**的TCP发送一个连接请求报文段 SYN=1             seq=x
  * **服务器**的TCP收到连接请求报文段后，如同意建立连接就向**客户机**发回确认，并为该TCP连接分配TCP缓存和变量 SYN=1    ACK=1              ack=x+1      seq=y
  * 当**客户机**收到确认报文段后，还要向**服务器**给出确认，并且也要给该连接分配缓存和变量  ACK=1            ack=y+1       seq=x+1
* **TCP四次释放连接：**
  * **客户机**向其TCP发送一个连接释放报文段，并停止发送数据，主动关闭TCP连接 FIN=1   seq=u
  * **服务器**收到连接释放报文段后即发出确认   ACK=1   seq=v    ack=u+1
  * **服务器**通知**客户端**TCP释放连接  FIN=1     ACK=1    seq=w     ack=u+1
  * **客户机**受到连接释放报文后，发出确认  ACK=1     seq=u+1    ack=w+1

> TCP报文段：ACK确认位	SYN同步位	FIN中止位

### HTTP的GET和POST区别

从原理性看：

- 根据HTTP规范，GET用于信息获取，而且应该是安全和幂等的
- 根据HTTP规范，POST请求表示可能修改服务器上资源的请求

从表面上看：

- GET请求的数据会附在URL后面，POST的数据放在HTTP包体

- POST安全性比GET安全性高

  

- GET：对服务器资源的简单请求
- POST：用于发送包含用户提交数据的请求
- HEAD：类似于GET请求，不过返回的响应中没有具体内容，用于获取报头
- PUT：传说中请求文档的一个版本
- DELETE：发出一个删除指定文档的请求
- TRACE：发送一个请求副本，以跟踪其处理进程
- OPTIONS：返回所有可用的方法，检查服务器支持哪些方法
- CONNECT：用于ssl隧道的基于代理的请求

### TCP拥塞控制

接收窗口rwnd:接收方根据目前接接收缓存大小所许诺的最新窗口值，反映接收方的容量。

拥塞窗口cwnd:发送方根据自己估真的的网络拥寒程度而设置的窗口值， 反映网络的当前容量

发送窗口的上限值min[rwnd, cwnd]

**慢开始:**每经过一个往返时延T,拥塞窗口cwnd就会加倍；令拥塞窗口cwnd=1即一个最大报文段长度MSS，每收到 一个对新报文段的确认后将cwnd加1；使分组注入网络的速率更加合理；慢开始直把拥塞窗口cwnd增大到一个规定的开始门限sthresh (阈值)，然后改用拥塞避免算法。
**拥塞避免**发送端的拥塞窗口cwnd每经过一个往返时延RTT就增加一个MSS的大小，而不是加倍；cwnd按线性规律缓慢增长(即加法增大)，而当出现一次超时 (网络拥塞)时，令慢开始门ssthresh等于当前cwnd的一半

**快重传：** 当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设的传计时器超时 

**快恢复：** 发送端收到连续三个冗余ACK (即重复确认)时，执行"乘法减小"算法，把慢开始窗口设为出现拥塞时发送方cwnd一半。把cwnd的值设置为慢开始门限sthresh改变后的数值，然后开始执行拥塞避免算法 (“加法增大”)。

### 端口号

FTP:21	SSH:22		DNS:53	HTTP:80	DNS:53	HTTPS:443

### HTTP状态码

- 200 - 请求成功

- 301 - 资源（网页等）被永久转移到其它URL

- 302 - 临时移动，资源只是临时被移动 客户端应继续使用原有URL

- 403 - Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求


- 404 - 请求的资源（网页等）不存在

- 408	Request Time-out	服务器等待客户端发送的请求时间过长，超时

- 500 - 内部服务器错误



### 浏览器输入URL到页面展现

1:ip地址寻址（首先浏览器缓存查找ip地址；host文件查找是否有配置该ip地址；路由器缓存查找ip地址；DNS服务器查找，更高级DNS服务器查找；直到找到为止）
		2:请求数据（首先发起连接请求进行tcp三次握手，连接成功后服务器会返回相应数据，进行TCP断开连接四次挥手）
		3:页面展现（解析html文件创建dom树，解析css形成css对象模型，结合dom，css构建渲染树，最后布局和绘制渲染树） 

- `HTML`被HTML解析器解析成`DOM` 树
- `css`则被css解析器解析成`CSSOM `树
- 结合`DOM`树和`CSSOM`树，生成一棵渲染树(`Render Tree`)
- 生成布局（`flow`），即将所有渲染树的所有节点进行平面合成
- 将布局绘制（`paint`）在屏幕上



###  JSON和XML
 JSON和XML都是数据传输的通用格式
1. 传输同样的报文，JSON体积小，传输速度快
2. 数据解析方面，JSON与JS交互更方便，开发更容易
3. 可读性，JSON可读性较xml差一些
4. 传输速度，JSON体积小，传输速度更快 



### cookie、session

session storage 本地存储一个会话中的数据 数据会在同一个会话中才能访问 会话结束后数据就会销毁

非持久化的 会讲话级别的

local storage 持久化本地存储 主动删除才会没有

cookie 存储在本地的一小段数据 每次向服务器发送请求的时候 cookie也会被一起发送过去  不应用做前端数据交换

### 实现继承

**原型链继承** 写个父类、子类，**子类的原型为父类的实例**，子类.prototype = new 父类；**修正子类原型为子类本身** 子类.prototype.constructor=子类 new 子类 **即可调用父类方法** 构造函数继承 写个父类、子类 在子类中父类.call(this) 即可实现



### 闭包

当一个内部函数被调用，就会形成闭包，闭包就是能够读取其他函数内部变量的函数。 

**闭包作用：** 局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。 



### 堆和栈的区别

* 栈由系统自动分配，而堆是人为申请开辟
* 栈获得的空间较小，而堆获得的空间较大
* 栈由系统自动分配，速度较快，而堆一般速度比较慢
* 栈是连续的空间，而堆是不连续的空间 

### 常见排序和时间复杂度 

| 排序算法 | 时间复杂度 | 空间复杂度 | 稳定性 |
| -------- | ---------- | ---------- | ------ |
| 冒泡排序 | O(n^2)     | O(1)       | 稳定   |
| 选择排序 | O(n^2)     | O(1)       | 不稳定 |
| 插入排序 | O(n^2)     | O(1)       | 稳定   |
| 希尔排序 | -          | O(1)       | 不稳定 |
| 归并排序 | O(nlogn)   | O(n)       | 稳定   |
| 快速排序 | O(nlogn)   | O(logn)    | 不稳定 |
| 堆排序   | O(nlogn)   | O(1)       | 不稳定 |
| 计数排序 | O(n+k)     | O(k)       | 稳定   |
| 桶排序   | O(n+k)     | O(n+k)     | 稳定   |
| 基数排序 | O(n*k)     | O(n+k)     | 稳定   |



###  

### 什么是中断？举几个中断的例子

 CPU对系统发生的某个事件作出的一种反应，停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行 。时钟中断		I/O请求中断

异常【 陷入 、 故障  （缺页故障）、 终止（整数除零）】

### 虚拟内存

**虚拟内存** 可以让程序可以拥有超过系统物理内存大小的可用内存空间。

虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程拥有一片连续完整的内存空间。

定义了一个连续的虚拟地址空间，并且把内存扩展到硬盘空间.

### MySQL为什么用B+树 

- B 树的叶子节点都是独立的;B+树的叶子节点**有一条引用链**指向与它相邻的叶子节点。
- B 树的检索的过程相当于对范围内的**每个节点的关键字做二分查找**，可能还没有到达叶子节点，检索就结束了。而 B+树的检索**效率就很稳定**了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显
- B+树非叶子节点不存储数据，所以每一层能够存储的索引数量会增加，意味b+树在层高相同的情况下存储数据量要比b树要多，使得**磁盘io次数更少**
- B+树的所有存储在叶子节点的数据使用了双向链表来关联，所以在查询的时候只需要查两个节点进行遍历就行，B+树在范围查询效率更高 



